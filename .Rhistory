agpop
library(SDaA)
library(survey)
library(psych)
#data(package='SDaA')
data(agpop)
dim(agpop); head(agpop)
(N=nrow(agpop))
levels(agpop$region)
set.seed(59)
index.str=stratsample(agpop$region,c('NE'=21,'NC'=103,'S'=135,'W'=41)) # 'stratsample' is in package "survey"
my.str=agpop[index.str,]
boxplot(my.str$acres92/10^6~my.str$region,col='lightgray',main='',names=c('NC','NE','S','W'),ylab='Millions of Acres')
describeBy(my.str$acres92,my.str$region) # 'describeBy' is in package "psych"
NE.str=my.str[my.str$region=='NE',]
(m.NE=mean(NE.str$acres92))
(v.NE=var(NE.str$acres92))
N.NE=220; n.NE=nrow(NE.str)
(that.NE=N.NE*m.NE)
(Vhat.that.NE=N.NE^2*(1-n.NE/N.NE)*v.NE/n.NE)
index.str <- stratsample(agpop$region, c("NE"=8,"NC"=69,"S"=122,"W"=101))
my.str <- agpop[index.str, ]
index.str
index.str
my.str
my.str[my.str$region == "NE", ]
my.str[my.str$region == "NE", ]$acres92
knitr::opts_chunk$set(echo = TRUE)
nrow(NE.str)
?stratsample
c("NE"=8,"NC"=69,"S"=122,"W"=101)
library(SDaA)
library(survey)
data(agpop)
set.seed(123)
index.str <- stratsample(agpop$region, c("NE"=8,"NC"=69,"S"=122,"W"=101))
my.str <- agpop[index.str, ]
NE.str <- my.str[my.str$region == "NE", ]
m.NE <- mean(NE.str$acres92)
v.NE <- var(NE.str$acres92)
N.NE <- 220
n.NE <- nrow(NE.str)
that.NE <- N.NE * m.NE
Vhat.that.NE <- N.NE^2 * (1 - n.NE/N.NE) * v.NE/n.NE
NC.str <- my.str[my.str$region == "NC", ]
m.NC <- mean(NC.str$acres92)
v.NC <- var(NC.str$acres92)
N.NC <- 1054
n.NC <- nrow(NC.str)
that.NC <- N.NC * m.NC
Vhat.that.NC < N.NC^2 * (1 - n.NC/N.NC) * v.NC/n.NC
Vhat.that.NC <- N.NC^2 * (1 - n.NC/N.NC) * v.NC/n.NC
S.str <- my.str[my.str$region=="S", ]
m.S <- mean(S.str$acres92)
v.S <- var(S.str$acres92)
N.S <- 1382
n.S <- nrow(S.str)
that.S <- N.S * m.S
Vhat.that.S <- N.S^2 * (1 - n.S/N.S) * v.S/n.S
W.str <- my.str[my.str$region == "W", ]
m.W <- mean(W.str$acres92)
v.W <- var(W.str$acres92)
N.W <- 422
n.W <- nrow(W.str)
N.W <- 422
n.W <- nrow(W.str)
that.W <- N.W * m.W
Vhat.that.W <- N.W^2 * (1 - n.W/N.W) * v.W/n.W
that.str <- that.NE + that.NC + that.S + that.W
Vhat.that.str <- Vhat.that.NE + Vhat.that.NC + Vhat.that.S + Vhat.that.W
SE.that.str <- sqrt(Vhat.that.str)
Vhat.that.W
sqrt(Vhat.that.W)
library(SDaA)
library(survey)
data(agpop)
set.seed(123)
index.str <- stratsample(agpop$region, c("NE"=8,"NC"=69,"S"=122,"W"=101))
my.str <- agpop[index.str, ]
NE.str <- my.str[my.str$region == "NE", ]
m.NE <- mean(NE.str$acres92)
v.NE <- var(NE.str$acres92)
N.NE <- 220
n.NE <- nrow(NE.str)
that.NE <- N.NE * m.NE
Vhat.that.NE <- N.NE^2 * (1 - n.NE/N.NE) * v.NE/n.NE
NC.str <- my.str[my.str$region == "NC", ]
m.NC <- mean(NC.str$acres92)
v.NC <- var(NC.str$acres92)
N.NC <- 1054
n.NC <- nrow(NC.str)
that.NC <- N.NC * m.NC
Vhat.that.NC <- N.NC^2 * (1 - n.NC/N.NC) * v.NC/n.NC
S.str <- my.str[my.str$region == "S", ]
m.S <- mean(S.str$acres92)
v.S <- var(S.str$acres92)
N.S <- 1382
n.S <- nrow(S.str)
that.S <- N.S * m.S
Vhat.that.S <- N.S^2 * (1 - n.S/N.S) * v.S/n.S
W.str <- my.str[my.str$region == "W", ]
m.W <- mean(W.str$acres92)
v.W <- var(W.str$acres92)
N.W <- 422
n.W <- nrow(W.str)
that.W <- N.W * m.W
Vhat.that.W <- N.W^2 * (1 - n.W/N.W) * v.W/n.W
that.str <- that.NE + that.NC + that.S + that.W
Vhat.that.str <- Vhat.that.NE + Vhat.that.NC + Vhat.that.S + Vhat.that.W
SE.that.str <- sqrt(Vhat.that.str)
Vhat.that.str
sqrt(Vhat.that.str)
names(c("NE"=8,"NC"=69,"S"=122,"W"=101))
n$NE
n.h <- c("NE"=8, "NC"=69, "S"=122, "W"=101) # From Exercise 3.12
n$NE
n.h$NE
n.h
n["NE"]
n.h["NE"]
class(n.h["NE"])
data(agpop)
set.seed(123)
N.h <- c("NE"=220, "NC"=1054, "S"=1382, "W"=422)
data(agpop)
N.h <- c("NE"=220, "NC"=1054, "S"=1382, "W"=422)
n.h <- c("NE"=8, "NC"=69, "S"=122, "W"=101) # From Exercise 3.12
set.seed(123)
index.str <- stratsample(agpop$region, n.h)
my.str <- agpop[index.str, ]
for (stratum in names(N.h)){
stratum
}
for (stratum in names(N.h)){
print(stratum)
}
data(agpop)
N.h <- c("NE"=220, "NC"=1054, "S"=1382, "W"=422)
n.h <- c("NE"=8, "NC"=69, "S"=122, "W"=101) # From Exercise 3.12
set.seed(123)
index.str <- stratsample(agpop$region, n.h)
my.str <- agpop[index.str, ]
for (stratum in names(N.h)){
h.str <- my.str[my.str$region == stratum, ]
m.h <- mean(NE.str$acres92)
v.h <- var(NE.str$acres92)
that.h <- N[stratum] * m.h
Vhat.that.h <- N.h[stratum]^2 * (1 - n.h[stratum]/N.h[stratum]) * v.h/n.h[stratum]
}
N.h[stratum]
N.h[stratum]
n.h[stratum]
data(agpop)
N.h <- c("NE"=220, "NC"=1054, "S"=1382, "W"=422)
n.h <- c("NE"=8, "NC"=69, "S"=122, "W"=101) # From Exercise 3.12
set.seed(123)
index.str <- stratsample(agpop$region, n.h)
my.str <- agpop[index.str, ]
for (stratum in names(N.h)){
h.str <- my.str[my.str$region == stratum, ]
m.h <- mean(NE.str$acres92)
v.h <- var(NE.str$acres92)
that.h <- N.h[stratum] * m.h
Vhat.that.h <- N.h[stratum]^2 * (1 - n.h[stratum]/N.h[stratum]) * v.h/n.h[stratum]
}
that.str <- sum(that.h)
Vhat.that.str <- sum(Vhat.that.h)
SE.that.str <- sqrt(Vhat.that.str)
SE.that.str
data(agpop)
N.h <- c("NE"=220, "NC"=1054, "S"=1382, "W"=422)
n.h <- c("NE"=8, "NC"=69, "S"=122, "W"=101) # From Exercise 3.12
set.seed(123)
index.str <- stratsample(agpop$region, n.h)
my.str <- agpop[index.str, ]
for (stratum in names(N.h)){
h.str <- my.str[my.str$region == stratum, ]
m.h <- mean(NE.str$acres92)
v.h <- var(NE.str$acres92)
that.h <- N.h[stratum] * m.h
Vhat.that.h <- N.h[stratum]^2 * (1 - n.h[stratum]/N.h[stratum]) * v.h/n.h[stratum]
}
that.str <- sum(that.h)
Vhat.that.str <- sum(Vhat.that.h)
SE.that.str <- sqrt(Vhat.that.str)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(glmnet)
library(caret)
library(pROC)
library(VIM)
#library(performanceEstimation)
#library(mlr)
#library(UBL)
dat <- read.csv("/Users/yctang/Documents/Columbia/5291 Advanced data Analysis/project/data/hmda_2017_ny_all-records_labels.csv")
dat <- read.csv("/Users/yctang/Documents/Columbia/Fall2021/5291 Advanced data Analysis/project/data/hmda_2017_ny_all-records_labels.csv")
# remove some variables & NA
dat <- subset(dat, select = -c(1:4, 6, 8, 10, 12, 15, 17, 19:27, 29, 31, 33:50, 51, 53, 54, 56:71, 69:71, 78))
#aggr(dat)
# drop missing values
dat <- drop_na(dat)
# some adjustments: re-encoding
# owner_occupancy: other == 0, Owner-occupied as a principal dwelling == 1
dat[dat$owner_occupancy == 2, ]$owner_occupancy <- 0
dat[dat$owner_occupancy == 3, ]$owner_occupancy <- 0
# loan_type: other == 0, Conventional == 1
dat[dat$loan_type == 2, ]$loan_type <- 0
dat[dat$loan_type == 3, ]$loan_type <- 0
dat[dat$loan_type == 4, ]$loan_type <- 0
# preapproval: not requested == 0
dat[dat$preapproval == 2, ]$preapproval <- 0
dat[dat$preapproval == 3, ]$preapproval <- 0
# action_taken
dat = dat %>% filter(action_taken == 1 | action_taken == 2 | action_taken == 3)
dat[dat$action_taken == 2, ]$action_taken <- 1
dat[dat$action_taken == 3, ]$action_taken <- 0
# applicant_ethnicity: other == 0, hispanic/latino == 1
dat[dat$applicant_ethnicity == 2, ]$applicant_ethnicity <- 0
dat[dat$applicant_ethnicity == 3, ]$applicant_ethnicity <- 0
dat[dat$applicant_ethnicity == 4, ]$applicant_ethnicity <- 0
# sex: unknown == 0, male == 1, female == 2
dat[dat$applicant_sex == 3, ]$applicant_sex <- 0
dat[dat$applicant_sex == 4, ]$applicant_sex <- 0
# race: other == 0, asian == 1, Black or African American == 2, white == 3
dat[dat$applicant_race_1 == 1, ]$applicant_race_1 <- 0
dat[dat$applicant_race_1 == 4, ]$applicant_race_1 <- 0
dat[dat$applicant_race_1 == 6, ]$applicant_race_1 <- 0
dat[dat$applicant_race_1 == 7, ]$applicant_race_1 <- 0
dat[dat$applicant_race_1 == 2, ]$applicant_race_1 <- 1
dat[dat$applicant_race_1 == 3, ]$applicant_race_1 <- 2
dat[dat$applicant_race_1 == 5, ]$applicant_race_1 <- 3
names(dat)[names(dat) == "applicant_race_1"] <- "applicant_race"
# co-applicant, yes/no == 1/0
dat[dat$co_applicant_ethnicity == 2, ]$co_applicant_ethnicity <- 1
dat[dat$co_applicant_ethnicity == 3, ]$co_applicant_ethnicity <- 0
dat[dat$co_applicant_ethnicity == 4, ]$co_applicant_ethnicity <- 0
dat[dat$co_applicant_ethnicity == 5, ]$co_applicant_ethnicity <- 0
names(dat)[names(dat) == "co_applicant_ethnicity"] <- "co_applicant"
# Change classes of variables
dat$agency_code <- as.factor(dat$agency_code)
dat$loan_type <- as.factor(dat$loan_type)
dat$property_type <- as.factor(dat$property_type)
dat$loan_purpose <- as.factor(dat$loan_purpose)
dat$owner_occupancy <- as.factor(dat$owner_occupancy)
dat$preapproval <- as.factor(dat$preapproval)
dat$action_taken <- as.factor(dat$action_taken)
dat$applicant_ethnicity <- as.factor(dat$applicant_ethnicity)
dat$co_applicant <- as.factor(dat$co_applicant)
dat$applicant_race <- as.factor(dat$applicant_race)
dat$applicant_sex <- as.factor(dat$applicant_sex)
dat %>%
ggplot(aes(action_taken, fill = action_taken)) +
geom_bar()+
scale_y_continuous(labels = scales::percent)
#ggplot(dat, aes(x = action_taken)) +
#    geom_bar(aes(y = (..count..)/sum(..count..))) +
#    scale_y_continuous(formatter = 'percent')
set.seed(123456)
indices.old <- sample(1:nrow(dat), nrow(dat) * 0.7)
training.old <- dat[indices.old, ]
testing.old <- dat[-indices.old, ]
library(tidyverse)
library(glmnet)
library(caret)
library(pROC)
library(VIM)
#library(performanceEstimation)
#library(mlr)
#library(UBL)
dat <- read.csv("/Users/yctang/Documents/Columbia/Fall2021/5291 Advanced data Analysis/project/data/hmda_2017_ny_all-records_labels.csv")
# remove some variables & NA
dat <- subset(dat, select = -c(1:4, 6, 8, 10, 12, 15, 17, 19:27, 29, 31, 33:50, 51, 53, 54, 56:71, 69:71, 78))
#aggr(dat)
# drop missing values
dat <- drop_na(dat)
# some adjustments: re-encoding
# owner_occupancy: other == 0, Owner-occupied as a principal dwelling == 1
dat[dat$owner_occupancy == 2, ]$owner_occupancy <- 0
dat[dat$owner_occupancy == 3, ]$owner_occupancy <- 0
# loan_type: other == 0, Conventional == 1
dat[dat$loan_type == 2, ]$loan_type <- 0
dat[dat$loan_type == 3, ]$loan_type <- 0
dat[dat$loan_type == 4, ]$loan_type <- 0
# preapproval: not requested == 0
dat[dat$preapproval == 2, ]$preapproval <- 0
dat[dat$preapproval == 3, ]$preapproval <- 0
# action_taken
dat = dat %>% filter(action_taken == 1 | action_taken == 2 | action_taken == 3)
dat[dat$action_taken == 2, ]$action_taken <- 1
dat[dat$action_taken == 3, ]$action_taken <- 0
# applicant_ethnicity: other == 0, hispanic/latino == 1
dat[dat$applicant_ethnicity == 2, ]$applicant_ethnicity <- 0
dat[dat$applicant_ethnicity == 3, ]$applicant_ethnicity <- 0
dat[dat$applicant_ethnicity == 4, ]$applicant_ethnicity <- 0
# sex: unknown == 0, male == 1, female == 2
dat[dat$applicant_sex == 3, ]$applicant_sex <- 0
dat[dat$applicant_sex == 4, ]$applicant_sex <- 0
# race: other == 0, asian == 1, Black or African American == 2, white == 3
dat[dat$applicant_race_1 == 1, ]$applicant_race_1 <- 0
dat[dat$applicant_race_1 == 4, ]$applicant_race_1 <- 0
dat[dat$applicant_race_1 == 6, ]$applicant_race_1 <- 0
dat[dat$applicant_race_1 == 7, ]$applicant_race_1 <- 0
dat[dat$applicant_race_1 == 2, ]$applicant_race_1 <- 1
dat[dat$applicant_race_1 == 3, ]$applicant_race_1 <- 2
dat[dat$applicant_race_1 == 5, ]$applicant_race_1 <- 3
names(dat)[names(dat) == "applicant_race_1"] <- "applicant_race"
# co-applicant, yes/no == 1/0
dat[dat$co_applicant_ethnicity == 2, ]$co_applicant_ethnicity <- 1
dat[dat$co_applicant_ethnicity == 3, ]$co_applicant_ethnicity <- 0
dat[dat$co_applicant_ethnicity == 4, ]$co_applicant_ethnicity <- 0
dat[dat$co_applicant_ethnicity == 5, ]$co_applicant_ethnicity <- 0
names(dat)[names(dat) == "co_applicant_ethnicity"] <- "co_applicant"
# Change classes of variables
dat$agency_code <- as.factor(dat$agency_code)
dat$loan_type <- as.factor(dat$loan_type)
dat$property_type <- as.factor(dat$property_type)
dat$loan_purpose <- as.factor(dat$loan_purpose)
dat$owner_occupancy <- as.factor(dat$owner_occupancy)
dat$preapproval <- as.factor(dat$preapproval)
dat$action_taken <- as.factor(dat$action_taken)
dat$applicant_ethnicity <- as.factor(dat$applicant_ethnicity)
dat$co_applicant <- as.factor(dat$co_applicant)
dat$applicant_race <- as.factor(dat$applicant_race)
dat$applicant_sex <- as.factor(dat$applicant_sex)
dat %>%
ggplot(aes(action_taken, fill = action_taken)) +
geom_bar()+
scale_y_continuous(labels = scales::percent)
#ggplot(dat, aes(x = action_taken)) +
#    geom_bar(aes(y = (..count..)/sum(..count..))) +
#    scale_y_continuous(formatter = 'percent')
set.seed(123456)
indices.old <- sample(1:nrow(dat), nrow(dat) * 0.7)
training.old <- dat[indices.old, ]
testing.old <- dat[-indices.old, ]
full <- glm(action_taken ~., family = binomial(link = 'logit'), data = training.old)
#summary(fit)
test.prob <- predict(full, testing.old, type = "response")
test.pred <- as.numeric(ifelse(test.prob > 0.5, 1, 0))
confusionMatrix(data = as.factor(test.pred), reference = testing.old$action_taken, positive = "1")
test.roc <- roc(testing.old$action_taken ~ test.prob, plot = TRUE, print.auc = TRUE)
# outliers & standardization
hist(dat$applicant_income_000s)
plot(density(dat$population[dat$population < quantile(dat$population, 0.99)]))
lines(density(dat$applicant_income_000s[dat$applicant_income_000s < quantile(dat$applicant_income_000s, 0.99)]))
dat <- dat %>%
filter(applicant_income_000s < quantile(applicant_income_000s, 0.96)) %>%
filter(loan_amount_000s < quantile(loan_amount_000s, 0.96)) %>%
mutate(applicant_income = as.numeric(scale(applicant_income_000s, center = FALSE)),
loan_amount = as.numeric(scale(loan_amount_000s, center = FALSE)),
population = as.numeric(scale(population, center = FALSE)),
hud_median_family_income = as.numeric(scale(hud_median_family_income, center = FALSE)),
number_of_owner_occupied_units = as.numeric(scale(number_of_owner_occupied_units, center = FALSE)),
number_of_1_to_4_family_units = as.numeric(scale(number_of_1_to_4_family_units, center = FALSE)),
minority_population = minority_population / 100,
tract_to_msamd_income = tract_to_msamd_income / 100
) %>%
dplyr::select(-c(applicant_income_000s, loan_amount_000s)) %>%
dplyr::select(action_taken, everything())
hist(dat$applicant_income)
plot(density(dat$population))
lines(density(dat$applicant_income))
plot(density(dat$population[dat$population<quantile(dat$population, 0.99)]))
lines(density(dat$applicant_income[dat$applicant_income<quantile(dat$applicant_income, 0.99)]))
set.seed(123456)
dat <- sample_n(dat, 1000)
indices <- sample(1:nrow(dat), nrow(dat) * 0.7)
training <- dat[indices, ]
testing <- dat[-indices, ]
full <- glm(action_taken ~., family = binomial(link = 'logit'), data = training)
#summary(fit)
test.prob <- predict(full, testing, type = "response")
test.pred <- as.numeric(ifelse(test.prob > 0.5, 1, 0))
confusionMatrix(data = as.factor(test.pred), reference = testing$action_taken, positive = "1")
test.roc <- roc(testing$action_taken ~ test.prob, plot = TRUE, print.auc = TRUE)
# install the RSBID package
#install.packages("devtools")
#devtools::install_github("dongyuanwu/RSBID")
library(RSBID)
install.packages("devtools")
devtools::install_github("dongyuanwu/RSBID")
# install the RSBID package
#install.packages("devtools")
#devtools::install_github("dongyuanwu/RSBID")
library(RSBID)
ptm <- proc.time()
training.bal <- SMOTE_NC(training, "action_taken")
proc.time() - ptm # running time
training.bal.dummy <- data.frame(model.matrix( ~ ., training.bal)[, -1])
testing.dummy <- data.frame(model.matrix( ~ ., testing)[, -1])
X <- as.matrix(training.bal.dummy[-1])
Y <- training.bal.dummy$action_taken1
cv <- cv.glmnet(X, Y, family = "binomial")
fit.L1 <- glmnet(X, Y, family = "binomial", alpha = 1, lambda = cv$lambda.min)
# confusion matrix and roc curve
test.prob <- fit.L1 %>% predict(newx = as.matrix(testing.dummy[-1]))
test.pred <- as.numeric(ifelse(test.prob > 0.5, 1, 0))
mean(test.pred == testing.dummy$action_taken1)
confusionMatrix(data = as.factor(test.pred), reference = factor(testing.dummy$action_taken1), positive = "1")
test.roc <- roc(testing.dummy$action_taken1 ~ as.numeric(test.prob), plot = TRUE, print.auc = TRUE)
library(neuralnet)
ptm <- proc.time()
set.seed(123456)
NN = neuralnet(action_taken1 ~ ., training.bal.dummy, hidden = 5, linear.output = FALSE, err.fct = 'ce', stepmax = 1e7)
NN = neuralnet(action_taken1 ~ ., training.bal.dummy, hidden = 5, linear.output = FALSE, err.fct = 'ce', stepmax = 1e7)
proc.time() - ptm # running time
plot(NN)
predict_NN = compute(NN, testing.dummy[-1])
test.pred <- as.numeric(ifelse(predict_NN$net.result > 0.5, 1, 0))
mean(test.pred == testing.dummy$action_taken1)
confusionMatrix(data = as.factor(test.pred), reference = factor(testing.dummy$action_taken1), positive = "1")
test.roc <- roc(testing.dummy$action_taken1 ~ predict_NN$net.result, plot = TRUE, print.auc = TRUE)
install.packages("tidymodels")
install.packages("tidymodels")
library(tidymodels)
library(dotwhisker)
install.packages("dotwhisker")
library(broom.mixed)
install.packages("broom")
install.packages("broom")
library(broom.mixed)
install.packages("broom.mixed")
library(broom.mixed)
library(readr)
?read_csv
library(tidymodels)  # for the parsnip package, along with the rest of tidymodels
# Helper packages
library(readr)       # for importing data
library(broom.mixed) # for converting bayesian models to tidy tibbles
library(dotwhisker)  # for visualizing regression results
urchins <-
# Data were assembled for a tutorial
# at https://www.flutterbys.com.au/stats/tut/tut7.5a.html
read_csv("https://tidymodels.org/start/models/urchins.csv")
urchins
urchins <-
# Data were assembled for a tutorial
# at https://www.flutterbys.com.au/stats/tut/tut7.5a.html
read_csv("https://tidymodels.org/start/models/urchins.csv") %>%
# Change the names to be a little more verbose
setNames(c("food_regime", "initial_volume", "width"))
urchins
urchins <-
# Data were assembled for a tutorial
# at https://www.flutterbys.com.au/stats/tut/tut7.5a.html
read_csv("https://tidymodels.org/start/models/urchins.csv") %>%
# Change the names to be a little more verbose
setNames(c("food_regime", "initial_volume", "width")) %>%
# Factors are very helpful for modeling, so we convert one column
mutate(food_regime = factor(food_regime, levels = c("Initial", "Low", "High")))
urchins
as.tibble()
?as.tibble()
ggplot(urchins,
aes(x = initial_volume,
y = width,
group = food_regime,
col = food_regime)) +
geom_point() +
geom_smooth(method = lm, se = FALSE) +
scale_color_viridis_d(option = "plasma", end = .7)
lm_mod <- linear_reg()
lm_mod
lm_fit <-
lm_mod %>%
fit(width ~ initial_volume * food_regime, data = urchins)
lm_fit
lm(width~., data = urchins)
urchins
str(urchins)
lm(width~food_regime * initial_volume, data = urchins)
tidy(lm_fit)
summary(lm_fit)
tidy(lm_fit)
lm(width~food_regime * initial_volume, data = urchins)
summary(lm(width~food_regime * initial_volume, data = urchins))
tidy(lm_fit) %>%
dwplot(dot_args = list(size = 2, color = "black"),
whisker_args = list(color = "black"),
vline = geom_vline(xintercept = 0, colour = "grey50", linetype = 2))
tidy(lm_fit)
new_points <- expand.grid(initial_volume = 20,
food_regime = c("Initial", "Low", "High"))
new_points
mean_pred <- predict(lm_fit, new_data = new_points)
mean_pred
?predict
predict(lm_fit, new_data = new_points)
lm_fit
mean_pred
?expand.grid
library(skimr)
install.packages("skimr")
library(skimr)
data(cells, package = "modeldata")
？cells
?cells
View(cells)
qt(0.95)
qt(0.95, 1)
?distributions
qt(0.025)
qt(0.025,1)
qt(0.025,1, lower.tail = TRUE)
qt(0.025,1, lower.tail = FALSE)
qt(0.975,1, lower.tail = FALSE)
qt(0.005,1, lower.tail = FALSE)
qnorm(0.975)
qnorm(0.995)
qt(0.995, 99)
rep(1,3)
?rep
